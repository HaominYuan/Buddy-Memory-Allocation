- 读写锁的代码是非常简单的。如果一些线程想要去更新数据，它必须成对的去调用函数 `rwlock_acquire_writelock()` 去获取锁，调用 `rwlock_release_writelock() ` 函数去释放它。函数的内部使用的是 `writelock` 信号量去保证只有一个写线程能够获取这把锁。因此这个线程能够进入关键部分（ctitical section）去更新数据。
- 更有趣的部分是获取和释放读锁的这部分程序。当想要获取一把读锁时，读线程必须先要获取 `lock` 然后将 `readers` 的数目加一，这样做可以用于追踪正在读取此数据的线程的个数。在函数 `rwlock_acquire_readlock()` 中，最重要的部分是当第一个读线程获取读锁时，它同时也要获取写锁。
- 因此，当第一个读线程一旦获取了读锁时，更多的读线程也允许读数据。对于任何想写的线程来说，它们必须等待所有的读线程完成读取以后才能够进行写。